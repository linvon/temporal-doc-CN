---
id: learn-glossary
title: Glossary
---

Temporal 以独特的方式概念化软件开发。与 Temporal 共享重叠的方法和概念的产品很少。

因此以下术语在 Temporal中被重新定义，并在整个文档和参考资料中用于描述其相关内容。

### 活动

活动是实现您应用程序逻辑（例如调用服务或对媒体文件进行编码转换）的业务级别函数。

- 一个活动通常执行一个明确定义的动作；它可以短期或长期运行。
- 活动可以实现为同步方法，也可以完全异步地涉及多个进程。
- 可以根据提供的指数重试策略无限期重试活动。
- 如果由于某种原因未在指定的超时时间内完成活动，则会向**工作流**报告错误，该错误将决定如何处理该活动。活动持续时间没有限制。
- 活动支持**活动心跳**，有助于在活动执行失败的情况下更快地识别超时。

### 活动心跳

活动心跳向 Temporal 服务器提供了正在执行的**活动任务**的状态。

- 活动心跳有助于确保快速识别**活动**执行失败和超时。
- 活动心跳通过代码实现，并由[工作流]实现自行决定是否记录。
- 自定义**活动**进度信息可以包含在活动心跳中，并且可以在重试**活动**时使用。

### 活动ID

标识正在执行的**活动**的唯一 ID 。Id 可以由系统生成，也可以由调用 **活动 **的工作流代码提供。可以使用活动 ID 来异步完成**活动**。

### 活动任务

一个包含**活动**调用信息的任务，而活动通过**任务队列**传递给**活动 Worker**。

- 收到**活动任务**后，**活动 Worker**将执行相应的**活动**。

### 归档

归档功能是在**工作流**保留期过后自动将**事件历史记录**从正常持久性移动到 Blob 存储的功能。

- 归档的目的是能够在不影响持久性存储的情况下，在需要的情况下保留**事件历史记录**。
- 保留期过后，您可能要保留**事件历史记录**的原因有两个：
  1. 合规性：出于法律原因，**事件历史记录**可能需要长时间保存。
  2. 调试：可以参考较旧的**事件历史记录**以帮助进行调试。

### 客户端桩

客户端桩是 Java SDK 中的客户端代理，用于在其代表的实体上进行远程调用。

- 例如，要启动**工作流**，将通过特殊的 API 创建代表**工作流**的 Stub 对象。然后该 Stub 用于启动、查询或发信号通知相应的**工作流**。
- Go SDK不使用客户端桩。

### 命令

**工作流**持久化功能所请求的任何操作都称为命令。

- 例如编排**活动**、取消子**工作流**或启动计时器都是命令。
- **工作流任务**包含有命令的可选列表。
- **Worker**执行**工作流**会生成一个命令列表，作为工作流任务的结果。此列表作为**工作流任务**完成请求的一部分发送到 Temporal 服务。
- 每个命令都作为**事件**记录在**事件历史**记录中。例如，`StartTimer`命令被记录为相应的`TimerStarted`事件。

### 事件

Temporal 对于每个工作流跟踪的事件分位两种类型：

1. **命令**事件。
2. 其他。

- 命令事件是与**工作流 Worker**生成的**命令**相对应的事件。
- 所有其他事件表示**工作流**预期会发生的各种外部事件，例如**活动**完成，计时器触发，取消请求等。
- 所有事件均记录在**事件历史记录中**。

### 事件历史

事件历史是为您的应用程序追加日志的**活动**。

- 事件历史记录由 Temporal 服务持久化保留，从而可以从崩溃或故障中无缝恢复应用程序状态。
- 它还用作调试的审核日志。

### 本地活动

**本地活动**是一种在工作流代码相同的进程中直接调用的**活动**。

- 虽然本地活动消耗的资源少于正常**活动**，但其持续时间较短且缺乏速率限制。

### 命名空间

Temporal 支持多租户服务，独立的单元称为命名空间。

- 默认情况下，Temporal 服务使用“default”命名空间。如果未指定，则所有 API 和工具（例如 UI 和 CLI）都默认为“default”命名空间。因此如果您不打算使用多个命名空间，建议您使用默认命名空间。
- **任务队列**名称以及**工作流 ID**对应于特定的命名空间。例如当工作流启动时，它会在特定的命名空间中启动。
- Temporal 保证命名空间内的**工作流ID**唯一，并支持使用相同的**工作流ID**进行**工作流执行**（如果它们在不同的命名空间中）。
- 还可以通过特殊的 CRUD API 或通过[`tctl`](https://docs.temporal.io/docs/tctl/)为每个命名空间配置各种配置选项，例如保留期或存档目标。
- 在多集群部署中，命名空间是故障转移的单位。
- 每个命名空间一次只能在单个 Temporal 集群上处于活动状态。但是不同的命名空间可以在不同的群集中处于活动状态，并且可以独立进行故障转移。

### 查询

从调用者的角度来看，查询是一种同步操作，用于报告**工作流**的状态。

- 查询逻辑在**工作流**中以代码的形式实现。
- 查询本质上是只读的，不会影响工作流状态。

### 运行ID 

运行ID是时间 Temporal 分配给每个**工作流**运行的 UUID 。

- Temporal 临时保证一次只能打开一个具有给定**工作流ID**的**工作流执行**。但之后**工作流执行**完成后，如果配置的策略允许你也许可以在**工作流**已关闭或失败后使用相同的**工作流 ID**重新执行它。
- 每次这样的重新执行称为一次运行。运行 ID 用于唯一标识一次运行，因此它与其他的运行可以共享工作流 ID。

### 信号

信号是对**工作流**的外部异步请求。

- 信号可以在正在运行的**工作流**生命期的任何时间点向其传递通知或更新。

### 任务

任务是执行特定**活动**或**工作流**状态转换所需的上下文。

- 任务的类型有两种：
  1. **活动任务**
  2. **工作流任务**
- 单个**活动**执行对应于单个**活动 Task**，而**工作流执行**使用多个**工作流任务**。

### 任务队列

任务队列是**Worker **订阅并轮询以消费要执行的任务的队列。

- 每个任务队列都能够对**活动任务**和**工作流任务**进行排队。
- 任务队列依赖于与其余 Temporal 服务相同的持久性存储（任务队列不基于其他技术，例如Kafka）。

### 任务令牌

任务令牌是 Temporal **活动**的唯一关联ID 。

- **活动**完成调用将单个任务令牌或命名空间、工作流 ID 和活动 ID 作为一组参数。

### Worker

Worker 是承载**工作流**和**活动**实现的服务。

- 单个 Worker 实际上包含**Activity Worker**和**Workflow Worker**，它们抽象了逻辑分离并具有执行两种类型任务的能力。
- Worker 向 Temporal 服务轮询**任务**、执行**任务**，并将**任务**执行结果传达回 Temporal 服务。
- Worker 服务由 Temporal 用户开发，部署和运营。

### 工作流

编排活动的故障无感知、有状态函数。

- 工作流完全控制执行哪些**活动**以及执行顺序。
- 工作流仅能通过**活动**与外部世界交互。
- 使工作流代码变成工作流的重要因素是 Temporal 会保留其状态。因此承载工作流代码的 **Worker** 进程的任何失败都不会影响**工作流执行**。工作流将继续进行就好像这些失败没有发生一样。而同时**活动**可能由于任何原因随时会失败。
- 由于工作流代码是完全故障无感知的，因此可以保证实现者能获得有关**活动**失败或超时的通知并采取相应措施。
- 工作流的持续时间没有限制。

### 工作流执行

**工作流**的实例。

- 工作流执行可能包含多个**工作流**在运行。当**工作流**的**事件历史记录**太大时，可以使用“Continue as New”标志来调用下一个调用，以自动创建新的运行。

### 工作流ID

**工作流执行**的唯一标识符。

- Temporal 保证**命名空间**中 ID 的唯一性。
- 如果存在另一个打开的工作流执行，尝试使用重复的 ID 启动**工作流**会导致**already started**错误。但是此行为取决于`WorkflowIdReusePolicy`标志。如果设置为`ALLOW_DUPLICATE`，则可以使用相同的工作流 ID 开始新的执行。

### 工作流任务

工作流任务是一个**任务**，其中包含调用一个**工作流**的信息。

- 每次记录可能影响**工作流**状态的新外部事件时，包含该事件的**工作流**任务都会被添加到**任务队列**中，然后由**工作流Worker**处理。
- 处理新事件后，将使用**命令**列表完成工作流任务。
- 工作流任务的处理通常非常快，并且与**工作流**调用的操作持续时间无关。