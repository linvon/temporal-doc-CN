---
id: activities
title: Activities
---

Temporal 的核心抽象是故障无感知的有状态的工作流。但是由于确定性的执行要求，它们不允许直接调用任何外部 API。取而代之的是他们编排活动的执行。在最简单的形式中，Temporal 活动是一种受支持的语言中的函数或对象方法。如果发生故障Temporal 并不会恢复活动的状态。因此活动可以包含任何代码而不受限制。

活动通过任务队列异步调用。任务队列本质上是用于存储活动任务的队列，直到一个活跃的 Worker 将其消费为止。 Worker 通过调用活动实现的函数来处理活动。当函数返回时 Worker 将结果报告回 Temporal 服务，该服务随后将通知工作流此活动的完成。通过从一个不同的进程来完成活动，可以完全异步地实现该活动。

## 超时

Temporal 不对活动持续时间施加任何系统限制，而是由应用程序决定其执行超时时间。这些是可配置的活动超时选项：

- `ScheduleToStart`是从工作流请求活动执行到 Worker 开始执行活动的最长时间。导致此超时的原因通常是所有 Worker 都在忙碌或无法跟上请求频率。我们建议将此超时设置为在所有可能的 Worker 宕机的情况下工作流愿意等待活动执行的最长时间。
- `StartToClose` 是活动被 Worker 消费后可以执行的最长时间。
- `ScheduleToClose` 是从工作流请求活动执行到完成的最长时间。
- `Heartbeat`是两次心跳请求之间的最长时间。请参阅[长期运行活动](https://docs.temporal.io/docs/activities#long-running-activities)。

`ScheduleToClose`或者`ScheduleToStart`和`StartToClose`超时设置是必需的。

## 重试

由于 Temporal 无法恢复活动的状态，并且它们可以与任何外部系统进行通信，失败便是预料之内的事情。因此 Temporal 支持自动活动重试。任何活动在被引用时都可以伴随关联的重试策略。这是重试策略参数：

- `InitialInterval` 是第一次重试的退避间隔。
- `BackoffCoefficient`重试策略是指数的。该系数指定重试间隔的增长速度。系数1表示重试间隔始终等于`InitialInterval`。
- `MaximumInterval`指定重试之间的最大间隔。对于大于1的系数有用。
- `MaximumAttempts`指定在出现故障时尝试执行活动的次数。如果超出此限制，则错误将返回到调用活动的工作流。
- `NonRetryableErrorReasons`允许您指定不应重试的错误。例如，在某些情况下对无效参数错误进行重试没有任何意义。

在某些情况下，应该在失败时重试一个工作流的全部部分而不是一个活动。例如媒体编码工作流将文件下载到主机进行处理，然后将结果上传回存储。在此工作流中如果拥有 Worker 的主机死亡，则应在其他主机上重试所有三个活动。这些重试应该由工作流代码处理，因为它们的用例非常特定化。

## 长期活动

对于长时间运行的活动，我们建议您指定相对较短的心跳超时并持续心跳。这样即使是很长时间运行的活动， Worker 的故障也可以得到及时处理。指定心跳超时的活动应在其实现中*定期*调用心跳方法。

心跳请求可以包含进应用程序的特定部分。这对于保存活动执行进度很有用。如果活动由于缺少心跳而超时，则下一次执行该活动的尝试可以访问该进度并从该断点继续执行。

长期活动可以用作领导选举算法的一种特例。Temporal 超时用作第二种解决方案。因此这不是实时应用程序的解决方案。但是如果可以在几秒钟之内对过程的失败做出响应，那么 Temporal 心跳活动就非常合适。

此类领导选举的一种常见用例是监控。一个活动执行一个内部循环，该循环定期轮询一些 API 并检查某些条件。每次迭代也都会进行心跳。如果满足条件，那么活动将完成，从而使其工作流可以处理它。如果活动 Worker 死亡，则在超过心跳间隔后活动将超时，并在其他 Worker 上重试。同样该模式也适用于轮询 Amazon S3 存储桶中的新文件或 REST 和其他同步 API 中的响应。

## 取消

工作流可以请求取消活动。当前一项活动得知其被取消的唯一方法是通过心跳。当心跳请求失败并返回一个特殊错误时，表示活动已取消。然后由活动的实现来执行所有必要的清理并报告已完成清理。由工作流的实现来决定是要等待活动取消确认还是不等待直接继续执行。

活动心跳失败的另一种常见情况是，调用它的工作流处于完成状态。在这种情况下活动也将执行清除。

## 通过任务队列路由活动任务

活动通过任务队列分派给 Worker 。任务队列是 Worker 监听的队列。任务队列是高度动态且轻量级的。他们不需要显式注册。每个 Worker 进程都有一个任务队列也是可以的。通常情况下会有不止一种活动类型通过单个任务队列被调用。在某些情况下（例如主机路由），在多个任务队列上调用相同的活动类型也是正常的。

以下是在单个工作流中使用多个活动任务队列的一些用例：

- *流量控制*。从任务队列消费的 Worker 仅在性能足够时才请求活动任务。因此 Worker 永远不会因请求高峰而超负荷工作。如果请求活动执行的速度快于 Worker 的处理速度，则会将其积压在任务队列中。
- *节流*。每个活动 Worker 可以指定允许其处理任务队列上的活动的最大速率。即使有剩余性能也不会超过此限制。同时还支持全局任务队列速率限制。对于给定的任务队列，此限制适用于所有 Worker 。它通常用于限制活动调用的下游服务的负载。
- *独立部署一系列活动*。设想一种托管活动的服务，该服务可以独立于其他活动和工作流进行部署。要将活动任务发送到此服务，需要一个单独的任务队列。
- *具有不同性能的  Worker*。例如，有 GPU 的机器上的 Worker 与没有 GPU 机器上的 Worker 。在这种情况下，具有两个单独的任务队列使工作流可以选择将执行请求发送到哪个任务队列。
- *将活动路由到特定主机*。例如在媒体编码的情况下，转换和上传活动必须与下载主机在同一主机上运行。
- *将活动路由到特定进程*。例如某些活动加载大型数据集并将其缓存在其进程中。依赖此数据集的活动应路由到同一进程。
- *多重优先权*。每个优先级一个任务队列，每个优先级有一个 Worker 池。
- *版本控制*。活动的新的向后不兼容实现可能使用不同的任务队列。

## 异步活动完成

默认情况下，活动是取决于客户端库语言的函数或方法。函数返回后，活动即告完成。但是在某些情况下，活动实现是异步的。例如，它通过消息队列转发到外部系统，答复来自另一个队列。

为了支持此类用例，Temporal 允许在活动的函数完成时并不完成活动的实现。在这种情况下应使用单独的 API 来完成活动。这个 API 可以从原始活动 Worker 使用的任何进程（甚至使用不同的编程语言）中调用。

## 本地活动

有一些活动生存周期很短，不需要排队语义、流量控制、速率限制和路由功能。对于这些 Temporal 同样支持，叫做*本地活动*功能。本地活动与调用它们的工作流在同一工作进程中执行。考虑将本地活动用于具有以下特性的功能：

- 不超过几秒钟
- 不需要全局速率限制
- 不需要路由到特定的 Worker 或 Worker 池
- 可以与调用它们的工作流在同一二进制文件中实现

本地活动的主要好处是，与常规活动调用相比它们在利用 Temporal  服务资源方面效率更高，并且延迟开销要低得多。